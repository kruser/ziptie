/*
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 * 
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * The Original Code is Ziptie Client Framework.
 * 
 * The Initial Developer of the Original Code is AlterPoint.
 * Portions created by AlterPoint are Copyright (C) 2008,
 * AlterPoint, Inc. All Rights Reserved.
 * 
 * Contributor(s):
 */
package org.ziptie.adaptertool.art;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.OutputStream;
import java.io.PrintStream;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamWriter;

import org.apache.derby.jdbc.EmbeddedDriver;

/**
 */
@SuppressWarnings("nls")
public class Results
{
    private static final String COLSPAN = "colspan";
    private static final String BORDER = "border";
    private static final String WIDTH = "width";
    private static final String TABLE = "table";
    private static final String CLASS = "class";
    private static final String BOLD = "strong";
    private static final String TD = "td";
    private static final String TR = "tr";

    private Connection conn;

    /**
     * Create the results handler.
     * @throws SQLException when there is an issue initializing the database.
     */
    public Results() throws SQLException
    {
        File dir = new File("art");
        if (dir.isDirectory())
        {
            if (!delete(dir))
            {
                throw new RuntimeException("Unable to delete old database.");
            }
        }

        EmbeddedDriver d = new EmbeddedDriver();
        conn = d.connect("jdbc:derby:art;create=true", new Properties());

        Statement stmt = conn.createStatement();
        stmt.executeUpdate("CREATE TABLE tests ( "
                + "id INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL, "
                + "name VARCHAR(255) NOT NULL, "
                + "adapter VARCHAR(255) NOT NULL, "
                + "xpaths INTEGER NOT NULL "
                + ")");

        stmt.executeUpdate("CREATE TABLE errors ( "
                + "test_id INTEGER NOT NULL, "
                + "type VARCHAR(32) NOT NULL, "
                + "error VARCHAR(32672) NOT NULL "
                + ")");

        stmt.close();
    }

    /**
     * Write the result summary HTML to the given output stream.
     * @param out The stream to write to.
     * @throws XMLStreamException When there is an issue writing the XML. 
     * @throws SQLException When there is an issue reading from the database.
     */
    public void write(OutputStream out) throws XMLStreamException, SQLException
    {
        Statement stmt = conn.createStatement();

        XMLStreamWriter w = XMLOutputFactory.newInstance().createXMLStreamWriter(out);
        w.writeStartDocument();
        w.writeStartElement("html");
        w.writeStartElement("head");
        w.writeEndElement(); // head
        w.writeStartElement("body");

        w.writeStartElement(TABLE);
        w.writeAttribute(BORDER, "0");

        writeSummaryTable(stmt, w);

        w.writeEndElement(); // table

        w.writeStartElement("h4");
        w.writeCharacters("Tests:");
        w.writeEndElement();

        w.writeStartElement(TABLE);
        w.writeAttribute(CLASS, "tests");
        w.writeAttribute(BORDER, "1");
        w.writeAttribute(WIDTH, "95%");

        String prevAdapter = null;
        ResultSet r = stmt.executeQuery("SELECT t.id, t.name, t.adapter, count(e.error) "
                + "FROM tests t "
                + "LEFT JOIN errors e ON t.id = e.test_id "
                + "GROUP BY t.id, t.name, t.adapter "
                + "ORDER BY t.adapter ASC");
        while (r.next())
        {
            int id = r.getInt(1);
            String name = r.getString(2);
            String adapter = r.getString(3);
            int errorCount = r.getInt(4);

            if (!adapter.equals(prevAdapter))
            {
                prevAdapter = adapter;

                w.writeStartElement(TR);
                w.writeStartElement(TD);
                w.writeAttribute(COLSPAN, String.valueOf(3));
                w.writeStartElement(BOLD);
                w.writeCharacters(adapter);
                w.writeEndElement(); // bold
                w.writeEndElement(); // td
                w.writeEndElement(); // tr
            }

            w.writeStartElement(TR);
            w.writeStartElement(TD);
            w.writeCharacters(name);
            w.writeEndElement(); // td
            w.writeStartElement(TD);

            if (errorCount > 0)
            {
                w.writeStartElement("a");
                w.writeAttribute("href", "#test" + id);
                w.writeCharacters(errorCount + " errors");
                w.writeEndElement(); // a
            }
            else
            {
                w.writeCharacters("Pass");
            }

            w.writeEndElement(); // td
            w.writeEndElement(); // tr
        }
        r.close();

        w.writeEndElement(); // table

        w.writeStartElement("h4");
        w.writeCharacters("Errors:");
        w.writeEndElement();

        w.writeStartElement(TABLE);
        w.writeAttribute(CLASS, "errors");
        w.writeAttribute(BORDER, "1");
        w.writeAttribute(WIDTH, "95%");

        int prevId = -1;

        r = stmt.executeQuery("SELECT id, name, type, error FROM tests t, errors e WHERE t.id = e.test_id ORDER BY id, type ASC");
        while (r.next())
        {
            int id = r.getInt(1);
            String name = r.getString(2);
            String type = r.getString(3);
            String error = r.getString(4);

            if (prevId != id)
            {
                prevId = id;
                w.writeStartElement(TR);
                w.writeStartElement(TD);
                w.writeAttribute(COLSPAN, String.valueOf(2));
                w.writeStartElement("a");
                w.writeAttribute("name", "test" + id);
                w.writeStartElement(BOLD);
                w.writeCharacters(name);
                w.writeEndElement(); // bold
                w.writeEndElement(); // a
                w.writeEndElement(); // td
                w.writeEndElement(); // tr
            }

            w.writeStartElement(TR);
            w.writeStartElement(TD);
            w.writeCharacters(type);
            w.writeEndElement(); // td
            w.writeStartElement(TD);
            w.writeStartElement("pre");
            w.writeCharacters(error);
            w.writeEndElement(); // pre
            w.writeEndElement(); // td
            w.writeEndElement(); // tr
        }
        r.close();
        w.writeEndElement(); // table

        w.writeEndElement(); // body
        w.writeEndElement(); // html
        w.writeEndDocument();
        w.flush();

        stmt.close();
    }

    private void writeSummaryTable(Statement stmt, XMLStreamWriter w) throws SQLException, XMLStreamException
    {
        ResultSet r = stmt.executeQuery("SELECT count(*) FROM tests");
        if (r.next())
        {
            writeSummary(w, "Test Count:", String.valueOf(r.getInt(1)));
        }
        r.close();

        r = stmt.executeQuery("SELECT count(*) FROM tests t LEFT JOIN errors e ON t.id = e.test_id WHERE e.error IS NULL");
        if (r.next())
        {
            writeSummary(w, "Tests Passed:", String.valueOf(r.getInt(1)));
        }
        r.close();

        r = stmt.executeQuery("SELECT SUM(xpaths) FROM tests");
        if (r.next())
        {
            writeSummary(w, "XPath Tests:", String.valueOf(r.getInt(1)));
        }
        r.close();

        r = stmt.executeQuery("SELECT count(*) FROM errors WHERE type = 'XPATH'");
        if (r.next())
        {
            writeSummary(w, "XPath Failures:", String.valueOf(r.getInt(1)));
        }
        r.close();

        r = stmt.executeQuery("SELECT count(*) FROM errors WHERE type = 'BASELINE' GROUP BY test_id");
        if (r.next())
        {
            writeSummary(w, "Baseline Failures:", String.valueOf(r.getInt(1)));
        }
        r.close();
    }

    private void writeSummary(XMLStreamWriter w, String label, String value) throws XMLStreamException
    {
        w.writeStartElement(TR);

        w.writeStartElement(TD);
        w.writeAttribute(CLASS, "summary_label");
        w.writeCharacters(label);
        w.writeEndElement();

        w.writeStartElement(TD);
        w.writeAttribute(CLASS, "summary_value");
        w.writeCharacters(value);
        w.writeEndElement();

        w.writeEndElement(); // tr
    }

    /**
     * Close the result handler (including the underlying database connection)
     * @throws SQLException If there is a database error.
     */
    public void close() throws SQLException
    {
        conn.close();
    }

    /**
     * Add the test.
     * @param name The name of the test.
     * @param adapterId The adapterId that the test uses.
     * @param xpathCount The number of XPath expression in this test.
     * @return The ID for the test instance that should be used when referencing this test.
     */
    public int addTest(String name, String adapterId, int xpathCount)
    {
        try
        {
            PreparedStatement stmt = conn.prepareStatement("INSERT INTO tests (name, adapter, xpaths) VALUES(?, ?, ?)", Statement.RETURN_GENERATED_KEYS);
            try
            {
                stmt.setString(1, name);
                stmt.setString(2, adapterId);
                stmt.setInt(3, xpathCount);
                stmt.executeUpdate();

                ResultSet r = stmt.getGeneratedKeys();
                if (!r.next())
                {
                    throw new RuntimeException("Test failed to insert.");
                }
                return r.getInt(1);
            }
            finally
            {
                stmt.close();
            }
        }
        catch (SQLException e)
        {
            throw new RuntimeException(e);
        }
    }

    /**
     * Add an error for the given test.
     * @param test The test ID
     * @param type The error type.
     * @param error The error.
     */
    public void addError(int test, Type type, Throwable error)
    {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        PrintStream ps = new PrintStream(baos);
        error.printStackTrace(ps);
        ps.flush();
        addError(test, type, baos.toString());
    }

    /**
     * Add an error for the given test.
     * @param test The test ID
     * @param type The error type.
     * @param error The error.
     */
    public void addError(int test, Type type, String error)
    {
        try
        {
            PreparedStatement stmt = conn.prepareStatement("INSERT INTO errors (test_id, type, error) VALUES(?, ?, ?)");
            try
            {
                stmt.setInt(1, test);
                stmt.setString(2, type.name());
                stmt.setString(3, error);
                stmt.executeUpdate();
            }
            finally
            {
                stmt.close();
            }
        }
        catch (SQLException e)
        {
            throw new RuntimeException(e);
        }
    }

    private static boolean delete(File path)
    {
        if (path.exists())
        {
            File[] files = path.listFiles();
            for (int i = 0; i < files.length; i++)
            {
                if (files[i].isDirectory())
                {
                    delete(files[i]);
                }
                else
                {
                    files[i].delete();
                }
            }
        }
        return path.delete();
    }

    /**
     * The available error types.
     */
    public enum Type
    {
        XPATH,
        BASELINE,
        VALIDATION,
        GENERAL,
    }
}
